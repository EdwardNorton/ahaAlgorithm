冒泡排序
简化版的桶排序不仅仅有上一节所遗留的问题，更要命的是：它非常浪费空间！例如需要排序数的范围是0~2100000000之间，
那你则需要申请2100000001 个变量，也就是说要写成int a[2100000001]。因为我们需要用2100000001 个“桶”来存储0~2100000000 之间每一
个数出现的次数。即便只给你5 个数进行排序（例如这5 个数是1、1912345678、2100000000、18000000 和912345678），
你也仍然需要2100000001 个“桶”，这真是太浪费空间了！还有，如果现在需要排序的不再是整数而是一些小数，
比如将5.56789、2.12、1.1、3.123、4.1234这五个数进行从小到大排序又该怎么办呢？
现在我们来学习另一种新的排序算法：冒泡排序。
冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。
最后我们总结一下：如果有 n 个数进行排序，只需将n1 个数归位，也就是说要进行
n-1 趟操作。而“每一趟”都需要从第1 位开始进行相邻两个数的比较，将较小的一个数放
在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一
个尚未归位的数，已经归位的数则无需再进行比较
###  
    #include <stdio.h>
    int main()
    {
    int a[100],i,j,t,n;
    scanf("%d",&n); //输入一个数n，表示接下来有n个数
    for(i=1;i<=n;i++) //循环读入n个数到数组a中
        scanf("%d",&a[i]);
    //冒泡排序的核心部分
    for(i=1;i<=n-1;i++) //n个数排序，只用进行n-1趟
    {
    for(j=1;j<=n-i;j++) //从第1位开始比较直到最后一个尚未归位的数，想一想为什么到n-i就可以了。
    {
    if(a[j]<a[j+1]) //比较大小并交换
    { t=a[j]; a[j]=a[j+1]; a[j+1]=t; }
    }
    }
    for(i=1;i<=n;i++) //输出结果
       printf("%d ",a[i]);
    getchar();getchar();
    return 0;
    }
    
    可以输入以下数据进行验证。
    10
    8 100 50 22 15 6 1 1000 999 0
    运行结果是：
    0 1 6 8 15 22 50 100 999 1000
