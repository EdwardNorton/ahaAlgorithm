三种排序实践
学校要建立一个图书角，老师派小哼去找一些同学做调查，看看同学们都喜欢读哪些书。小哼让每个同学写出一个自己最想读的书的ISBN 号
当然有一些好书会有很多同学都喜欢，这样就会收集到很多重复的ISBN 号。小哼需要去掉其中重复的ISBN 号，即每个ISBN 号只保留一个，
也就说同样的书只买一本。然后再把这些ISBN 号从小到大排序，小哼将按照排序好的ISBN 号去书店买书。
请你协助小哼完成“去重”与“排序”的工作。
输入有 2 行，第1 行为一个正整数，表示有n 个同学参与调查（n≤100）。第2 行有n个用空格隔开的正整数，为每本图书的ISBN 号
（假设图书的ISBN 号在1~1000 之间）。
输出也是 2 行，第1 行为一个正整数k，表示需要买多少本书。第2 行为k 个用空格隔开的正整数，
为从小到大已排好序的需要购买的图书的ISBN 号。
学校要买同学感兴趣的书，并且每本书仅买一本。
输入2行，第一行为一个正整数，表示有n个同学参与调查（n<=100）。
第2行有n个用空格隔开的正整数，为每本图书的号（1~1000）。
输出2行，第一行位要买书的本书k，第2行为k个用空格隔开的正整数，为从小到大已排好序的需要购买的图书的号。
解决方法：
先排序后去重；先去重后排序。
例如输入：
10
20 40 32 67 40 20 89 300 400 15
则输出：
8
15 20 32 40 67 89 300 400
桶排序
先来看第一种方法。通过第一节的学习我们发现，桶排序稍加改动正好可以起到去重的效果，因此我们可以使用桶排序的方法来解决此问题。
### 
    #include <stdio.h>
    int main()
    {
    int a[1001],n,i,t;
    for(i=1;i<=1000;i++)
      a[i]=0; //初始化
    scanf("%d",&n); //读入n
    for(i=1;i<=n;i++) //循环读入n个图书的ISBN号
    {
    scanf("%d",&t); //把每一个ISBN号读到变量t中
    a[t]=1; //标记出现过的ISBN号
    }
    for(i=1;i<=1000;i++) //依次判断1~1000这个1000个桶
    {
    if(a[i]==1)//如果这个ISBN号出现过则打印出来
    printf("%d ",i);
    }
    getchar();getchar();
    return 0;
    }
    
这种方法的时间复杂度就是桶排序的时间复杂度，为O(N+M)。
第二种方法我们需要先排序再去重。排序我们可以用冒泡排序或者快速排序。
20 40 32 67 40 20 89 300 400 15
将这10 个数从小到大排序之后为 15 20 20 32 40 40 67 89 300 400。
接下来，要在输出的时候去掉重复的。因为我们已经排好序，所以相同的数都会紧挨在一起。
只要在输出的时候，预先判断一下当前这个数a[i]与前面一个数a[i-1]是否相同。如果相同则表示这个数之前已经输出过了，
不用再次输出；不同则表示这个数是第一次出现，需要输出这个数。
冒泡排序
### 

        #include <stdio.h>
        int main()
        {
        int a[101],n,i,j,t;
        scanf("%d",&n); //读入n
        for(i=1;i<=n;i++) //循环读入n个图书ISBN号
        {
        scanf("%d",&a[i]);
        }
        //开始冒泡排序
        for(i=1;i<=n-1;i++)
        {
            for(j=1;j<=n-i;j++)
            {
            if(a[j]>a[j+1])
                 { t=a[j]; a[j]=a[j+1]; a[j+1]=t; }
             }
        }
        printf("%d ",a[1]); //输出第1个数
        for(i=2;i<=n;i++) //从2循环到n
        {
            if( a[i] != a[i-1] ) //如果当前这个数是第一次出现则输出
            printf("%d ",a[i]);
        }
        getchar();getchar();
        return 0;
        }
这种方法的时间复杂度由两部分组成，一部分是冒泡排序的时间复杂度，是N (N2)，另一部分是读入和输出，都是O(N)，
因此整个算法的时间复杂度是O(2*N+N 2)。相对于N2 来说，2*N 可以忽略（我们通常忽略低阶），最终该方法的时间复杂度是O(N2)。
我们来回顾一下三种排序算法的时间复杂度。桶排序是最快的，它的时间复杂度是O(N+M)；冒泡排序是O(N 2)；快速排序是O(NlogN)。
