解密QQ 号——队列
小哈给了小哼一串加密过的数字，同时小哈也告诉了小哼解密规则。
规则是这样的：首先将第1个数删除，紧接着将第2个数放到这串数的末尾，再将第3个数删除并将第4个数再放到这串数的末尾，
再将第5个数删除……直到剩下最后一个数，将最后一个数也删除。按照刚才删除的顺序，把这些删除的数连在一起就是小哈的QQ啦。
现在你来帮帮小哼吧。小哈给小哼加密过的一串数是“6 3 1 75 8 9 2 4”。
解密的过程就像是将这些数“排队”。每次从最前面拿两个，第1个扔掉，第2个放到尾部。具体过程是这样的：
刚开始这串数是“6 3 1 75 8 9 2 4”，首先删除6并将3放到这串数的末尾，这串数更新为“1 7 5 89 2 4 3”。
接下来删除1并将7放到末尾，即更新为“5 8 9 24 3 7”。再删除5并将8放到末尾即“9 2 4 3 7 8”，删除9并将2放到末尾即“4 3 7 8 2”，
删除4并将3放到末尾即“7 8 2 3”，删除7并将8放到末尾即“2 3 8”，删除2并将3放到末尾即“8 3”，删除8并将3放到末尾即“3”，最后删除3。
因此被删除的顺序是“6 1 5 9 4 7 2 8 3”，这就是小哈的QQ号码了
 首先需要一个数组来存储这一串数即intq[101]。并初始化这个数组即intq[101]={0,6,3,1,7,5,8,9,2,4};
 （此处初始化是我多写了一个0，用来填充q[0]，因为我比较喜欢从q[1]开始用
 引入两个整型变量head和tail。head用来记录队列的队首（即第一位），tail用来记录队列的队尾（即最后一位）的下一个位置。你可能会问为什么tail不直接记录队尾，却要记录队尾的下一个位置呢？这是因为当队列当中只剩下一个元素时，队首和队尾重合会带来一些麻烦。我们这里规定队首和队尾重合时，队列为空。

现在有9个数，9个数全部放入队列之后head=1;tail=10;此时head和tail之间的数就是目前队列中“有效”的数。如果要删除一个数的话，
就将head++就OK了，这样仍然可以保持head和tail之间的数为目前队列中“有效”的数。这样做虽然浪费了一个空间，却节省了大量的时间，
这是非常划算的。新增加一个数也很简单，把需要增加的数放到队尾即q[tail]之后再tail++就欧克啦。
  在队首删除一个数的操作是head++;
  在队尾增加一个数（假设这个数是x）的操作是q[tail]=x;tail++;  
  ### 

 
